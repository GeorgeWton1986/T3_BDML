# Extraer coordenadas
centroides_bogota <- centroides_bogota %>%
mutate(x = st_coordinates(centroides_bogota)[, "X"],
y = st_coordinates(centroides_bogota)[, "Y"])
# Convertir a objeto sf
centroides_bogota_sf <- st_as_sf(centroides_bogota, coords = c("x", "y"), crs = 4326)
# Visualizar los centroides de los parques en Bogotá
leaflet() %>%
addTiles() %>%
addCircles(data = centroides_bogota_sf, color = "darkgreen", radius = 50, opacity = 0.7)
# Convertir los apartamentos fuera de Chapinero a objeto sf
sf_aptos_sin_chapinero <- st_as_sf(train_localidades, coords = c("lon", "lat"), crs = 4326)
# Calcular la distancia entre apartamentos y centroides de parques de Bogotá
dist_matrix_sin_chapinero <- st_distance(sf_aptos_sin_chapinero, centroides_bogota_sf)
# Obtener la distancia mínima para cada apartamento
dist_min_sin_chapinero <- apply(dist_matrix_sin_chapinero, 1, min)
# Agregar la distancia mínima a la base de datos
train_localidades <- train_localidades %>%
mutate(distancia_parque = dist_min_sin_chapinero)
# Crear histograma
p2 <- ggplot(train_localidades, aes(x = distancia_parque)) +
geom_histogram(bins = 50, fill = "darkgreen", alpha = 0.5) +
labs(x = "Distancia mínima a un parque (m)", y = "Cantidad",
title = "Distribución de distancia a parques - resto de Bogotá") +
theme_bw()
ggsave("../04_Views/GRAFICO8B-DISTANCIAPARQUES_RESTO.png", plot = p2, dpi = 150, width = 8, height = 6)
train_localidades_tokens_clean %>%
count(word, sort = TRUE)
library(dplyr)
#Vector palabras agrupadas
parking <- c("parqueadero", "garaje", "parqueaderos", "garajes")
terrace <- c("terraza", "balcon")
gym <- "gimnasio"
laundry <- "lavanderia"
elevator <- "ascensor"
#Variable dummy para cada caracteristica
dummies_df <- train_localidades_tokens_clean %>%
mutate(binaria_parking = word %in% parking,
binaria_terrace = word %in% terrace,
binaria_gym = word %in% gym,
binaria_laundry = word %in% laundry,
binaria_elevator = word %in% elevator) %>%
group_by(property_id) %>%
summarise(across(starts_with("binaria_"), ~as.integer(any(.))))
# Unir a df
train_localidades <- left_join(train_localidades, dummies_df, by = "property_id")
View(train_localidades)
# 1. Carga de datos train
## Definir URL del archivo Excel en GitHub
url_excel_train <- "https://raw.githubusercontent.com/GeorgeWton1986/T3_BDML/refs/heads/main/03_Stores/train.csv"
## Descargar el archivo temporalmente
temp_file <- tempfile(fileext = ".csv")
GET(url_excel_train, write_disk(temp_file, overwrite = TRUE))
## Leer el archivo CSV en un dataframe
train_aptos <- read_csv(temp_file)
# 2. Carga de datos test hogares
## Definir URL del archivo Excel en GitHub
url_excel_test <- "https://raw.githubusercontent.com/GeorgeWton1986/T3_BDML/refs/heads/main/03_Stores/test.csv"
## Descargar el archivo temporalmente
temp_file <- tempfile(fileext = ".csv")
GET(url_excel_test, write_disk(temp_file, overwrite = TRUE))
# Leer el archivo CSV en un dataframe
test_aptos <- read_csv(temp_file)
# Nombre de las columnas de la base train_hogares
colnames(train_aptos)
# Seleccion de la columnas id de hogares
train_aptos %>%
select(property_id) %>%
head()
# Resumen de apartamentos de la base train_hogares
skim(train_aptos)
# Tratamiento de missing values
train_miss <- skim(train_aptos) %>%
filter(skim_type == "numeric") %>%
select(skim_variable, n_missing)
nobs_train <- nrow(train_aptos)
# Porcentaje de missing por cada caracteristica
train_aptos_miss<- train_miss %>%
mutate(p_missing= n_missing/nobs_train) %>%
filter(n_missing!= 0) %>%
arrange(-n_missing)
train_aptos_miss
# Visualizar variables con missing values
## Gráfico para surface_total (área total)
graf_ms1 <- ggplot(train_aptos, aes(surface_total)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
geom_vline(xintercept = median(train_aptos$surface_total, na.rm = TRUE), linetype = "dashed", color = "red") +
geom_vline(xintercept = mean(train_aptos$surface_total, na.rm = TRUE), linetype = "dashed", color = "blue") +
ggtitle("GRÁFICA 1 - Área total") +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO1-HISTOGRAMA-AREATOTAL.png", plot = graf_ms1, dpi = 150, width = 8, height = 6)
## Gráfico para surface_covered (área privada)
graf_ms2 <- ggplot(train_aptos, aes(surface_covered)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
geom_vline(xintercept = median(train_aptos$surface_covered, na.rm = TRUE), linetype = "dashed", color = "red") +
geom_vline(xintercept = mean(train_aptos$surface_covered, na.rm = TRUE), linetype = "dashed", color = "blue") +
ggtitle("GRÁFICA 2 - Área privada") +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO2-HISTOGRAMA-AREAPRIVADA.png", plot = graf_ms2, dpi = 150, width = 8, height = 6)
## Gráfico para rooms (habitaciones)
graf_ms3 <- ggplot(train_aptos, aes(rooms)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
geom_vline(xintercept = median(train_aptos$rooms, na.rm = TRUE), linetype = "dashed", color = "red") +
geom_vline(xintercept = mean(train_aptos$rooms, na.rm = TRUE), linetype = "dashed", color = "blue") +
ggtitle("GRÁFICA 3 -Habitaciones") +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO3-HISTOGRAMA-HABITACIONES.png", plot = graf_ms3, dpi = 150, width = 8, height = 6)
## Gráfico para bathrooms (baños)
graf_ms4 <- ggplot(train_aptos, aes(bathrooms)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
geom_vline(xintercept = median(train_aptos$bathrooms, na.rm = TRUE), linetype = "dashed", color = "red") +
geom_vline(xintercept = mean(train_aptos$bathrooms, na.rm = TRUE), linetype = "dashed", color = "blue") +
ggtitle("GRÁFICA 4 - Baños") +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO4-HISTOGRAMA-BAÑOS.png", plot = graf_ms4, dpi = 150, width = 8, height = 6)
# Imputación de variables con la mediana y moda
## 1. Variable surface_total con mediana
mediana_surface_total <- median(train_aptos$surface_total, na.rm = TRUE)
train_aptos <- train_aptos  %>%
mutate(surface_total = ifelse(is.na(surface_total) == TRUE, mediana_surface_total, surface_total))
## 2. Variable surface_covered con mediana
mediana_surface_covered <- median(train_aptos$surface_covered, na.rm = TRUE)
train_aptos <- train_aptos  %>%
mutate(surface_covered = ifelse(is.na(surface_covered) == TRUE, mediana_surface_covered, surface_covered))
## 3.  Variable rooms con la moda
moda_rooms <- train_aptos %>%
filter(!is.na(rooms)) %>%
count(rooms) %>%
arrange(desc(n)) %>%
slice(1) %>%
pull(rooms)
train_aptos <- train_aptos  %>%
mutate(rooms = ifelse(is.na(rooms) == TRUE, moda_rooms, rooms))
## 4.Variable bathrooms con la moda
moda_bathrooms <- train_aptos %>%
filter(!is.na(bathrooms)) %>%
count(bathrooms) %>%
arrange(desc(n)) %>%
slice(1) %>%
pull(bathrooms)
train_aptos <- train_aptos  %>%
mutate(bathrooms = ifelse(is.na(bathrooms) == TRUE, moda_bathrooms, bathrooms))
# Validación de correcta imputación de missing values en variables numéricas
skim(train_aptos)
train_aptos <- as.data.frame(train_aptos)
stargazer(train_aptos, type = "text")
# Calcular el precio por metro cuadrado
train_aptos <- train_aptos %>%
mutate(precio_mt2 = round(price / surface_total, 0))
skim(train_aptos)
# Histograma del precio por metro cuadrado
graf_5 <- ggplot(train_aptos, aes(precio_mt2)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
ggtitle("GRÁFICA 4 - Precio por metro cuadrado (millones)") +
scale_x_continuous(labels = function(x) x / 1e6) +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO5-HISTOGRAMA-PRECIOXMETROCUADRADO.png", plot = graf_5, dpi = 150, width = 8, height = 6)
# Box plot del precio por metro cuadrado
graf_6 <- train_aptos %>%
ggplot(aes(y = precio_mt2)) +
geom_boxplot(fill = "darkblue", alpha = 0.4) +
labs(
title = "Muestra completa",
y = "Precio por metro cuadrado (millones)", x = "") +
scale_y_continuous(labels = function(x) x / 1e6) +
theme_bw()
ggsave("../04_Views/GRAFICO6-BOXPLOT-PRECIOXMETROCUADRADO.png", plot = graf_6, dpi = 150, width = 8, height = 6)
# Ante outliers superiores se aplica la Metodología de percentil 99%
#p1 <- quantile(train_aptos$precio_mt2, probs = 0.01, na.rm = TRUE)
p99 <- quantile(train_aptos$precio_mt2, probs = 0.99, na.rm = TRUE)
train_aptos <- train_aptos %>%
filter(precio_mt2 <= p99)
# Filtrar solo los valores menores o iguales al límite superior
graf_7 <- train_aptos %>%
ggplot(aes(y = precio_mt2)) +
geom_boxplot(fill = "darkblue", alpha = 0.4) +
labs(
title = "Muestra filtrada - P99",
y = "Precio por metro cuadrado (millones)", x = "") +
scale_y_continuous(labels = function(x) x / 1e6) +
theme_bw()
ggsave("../04_Views/GRAFICO6-BOXPLOT-PRECIOXMETROCUADRADO-P99.png", plot = graf_7, dpi = 150, width = 8, height = 6)
# Observamos la primera visualización de la ubicación de los inmubles de la base train_aptos
leaflet() %>%
addTiles() %>%
addCircles(lng = train_aptos$lon,
lat = train_aptos$lat)
limites <- getbb("Chapinero, Bogotá, Colombia")
train_localidades <- train_aptos %>%
filter(
lon < limites[1, "min"] | lon > limites[1, "max"] |
lat < limites[2, "min"] | lat > limites[2, "max"]
)
# Visualizar
leaflet() %>%
addTiles() %>%
addCircles(lng = train_localidades$lon,
lat = train_localidades$lat)
View(train_localidades)
library(tidytext)
library(dplyr)
# Tokenización de la columna 'description'
train_localidades_tokens <- train_localidades %>%
unnest_tokens(word, description)
#Quitar stop words
data("stop_words")
train_localidades_tokens_clean <- train_localidades_tokens %>%
anti_join(stop_words)
train_localidades_tokens_clean %>%
count(word, sort = TRUE)
library(dplyr)
#Vector palabras agrupadas
parking <- c("parqueadero", "garaje", "parqueaderos", "garajes")
terrace <- c("terraza", "balcon")
gym <- "gimnasio"
laundry <- "lavanderia"
elevator <- "ascensor"
#Variable dummy para cada caracteristica
dummies_df <- train_localidades_tokens_clean %>%
mutate(binaria_parking = word %in% parking,
binaria_terrace = word %in% terrace,
binaria_gym = word %in% gym,
binaria_laundry = word %in% laundry,
binaria_elevator = word %in% elevator) %>%
group_by(property_id) %>%
summarise(across(starts_with("binaria_"), ~as.integer(any(.))))
# Unir a df
train_localidades <- left_join(train_localidades, dummies_df, by = "property_id")
limites <- getbb("Chapinero, Bogotá, Colombia")
# Asegurarse de que las coordenadas estén en EPSG:4326
train_aptos_sf <- st_as_sf(train_aptos, coords = c("lon", "lat"), crs = 4326)
# Filtrar límites
train_localidades <- train_aptos %>%
filter(
lon < limites[1, "min"] | lon > limites[1, "max"] |
lat < limites[2, "min"] | lat > limites[2, "max"]
)
# Visualizar
leaflet() %>%
addTiles() %>%
addCircles(lng = train_localidades$lon,
lat = train_localidades$lat)
# Definir el área de Chapinero
limites_chapinero <- getbb("Chapinero, Bogotá, Colombia")
# Descargar estaciones de bus de TransMilenio
transmi_query_bogota <- opq(bbox = limites_chapinero) %>%
add_osm_feature(key = "public_transport", value = "platform") %>%
add_osm_feature(key = "bus", value = "yes", value_exact = FALSE) %>%
osmdata_sf()
# Extraer las estaciones de bus como puntos
bus_stations_sf <- transmi_query_bogota$osm_points
# TRANSFORMAR CRS y calcular distancia en un solo paso para TRAIN
db_train <- st_transform(db_train, crs = st_crs(bus_stations_sf)) %>%
mutate(dist_bus_mts = st_distance(., bus_stations_sf) %>% apply(1, min))
# 1. Cargar datos espaciales de los apartamentos y CAIs en Bogotá
# Primero, asegúrate de que las columnas de latitud y longitud sean numéricas
train_aptos <- train_aptos %>%
mutate(lon = as.numeric(lon), lat = as.numeric(lat))
# 1. Cargar datos espaciales de los apartamentos y CAIs en Bogotá
# Primero, asegúrate de que las columnas de latitud y longitud sean numéricas
train_aptos <- train_aptos %>%
mutate(lon = as.numeric(lon), lat = as.numeric(lat))
# Convertir las coordenadas de los apartamentos a un objeto espacial (sf)
train_aptos_sf <- st_as_sf(train_aptos, coords = c("lon", "lat"), crs = 4326)
# Revisar el objeto espacial
print(train_aptos_sf)
limites <- getbb("Chapinero, Bogotá, Colombia")
# Las coordenadas en EPSG:4326
train_aptos_sf <- st_as_sf(train_aptos, coords = c("lon", "lat"), crs = 4326)
# Filtrar límites
train_localidades <- train_aptos %>%
filter(
lon < limites[1, "min"] | lon > limites[1, "max"] |
lat < limites[2, "min"] | lat > limites[2, "max"]
)
# Visualizar
leaflet() %>%
addTiles() %>%
addCircles(lng = train_localidades$lon,
lat = train_localidades$lat)
library(tidytext)
library(dplyr)
# Tokenización de la columna 'description'
train_localidades_tokens <- train_localidades %>%
unnest_tokens(word, description)
#Quitar stop words
data("stop_words")
train_localidades_tokens_clean <- train_localidades_tokens %>%
anti_join(stop_words)
train_localidades_tokens_clean %>%
count(word, sort = TRUE)
library(dplyr)
#Vector palabras agrupadas
parking <- c("parqueadero", "garaje", "parqueaderos", "garajes")
terrace <- c("terraza", "balcon")
gym <- "gimnasio"
laundry <- "lavanderia"
elevator <- "ascensor"
#Variable dummy para cada caracteristica
dummies_df <- train_localidades_tokens_clean %>%
mutate(binaria_parking = word %in% parking,
binaria_terrace = word %in% terrace,
binaria_gym = word %in% gym,
binaria_laundry = word %in% laundry,
binaria_elevator = word %in% elevator) %>%
group_by(property_id) %>%
summarise(across(starts_with("binaria_"), ~as.integer(any(.))))
# Unir a df
train_localidades <- left_join(train_localidades, dummies_df, by = "property_id")
# Obtener los límites de Bogotá
limites_bogota <- getbb("Bogotá, Colombia")
# Obtener los CAIs (estaciones de policía) en Bogotá desde OSM
cai_query_bogota <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "amenity", value = "police")
# Descargar datos de CAIs
cai_data_bogota <- osmdata_sf(cai_query_bogota)
# Extraer los puntos de los CAIs en Bogotá (como un objeto sf)
cai_sf_bogota <- cai_data_bogota$osm_points %>%
dplyr::select(osm_id, name) %>%
st_transform(crs = 4326)  # Asegurarse de que el CRS coincida con el de los apartamentos
# Revisar los datos de los CAIs
head(cai_sf_bogota)
# Calcular las distancias entre los apartamentos fuera de Chapinero y los CAIs
dist_matrix_cai <- st_distance(train_localidades_sf, cai_sf_bogota)
# Calcular las distancias entre los apartamentos fuera de Chapinero y los CAIs
dist_matrix_cai <- st_distance(train_localidades, cai_sf_bogota)
# Verificar CRS de ambos objetos
st_crs(train_localidades)
st_crs(cai_sf_bogota)
# Obtener los límites de Bogotá
limites_bogota <- getbb("Bogotá, Colombia")
# Obtener los CAIs (estaciones de policía) en Bogotá desde OSM
cai_query_bogota <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "amenity", value = "police")
# Descargar datos de CAIs
cai_data_bogota <- osmdata_sf(cai_query_bogota)
# Extraer los puntos de los CAIs en Bogotá como un objeto sf
cai_sf_bogota <- cai_data_bogota$osm_points %>%
dplyr::select(osm_id, name) %>%
st_transform(crs = 4326)  # Asegurarse de que el CRS coincida con el de los apartamentos
# Revisar los datos de los CAIs
head(cai_sf_bogota)
# Convertir 'train_localidades' a un objeto espacial (sf) con CRS EPSG:4326
train_localidades_sf <- st_as_sf(train_localidades, coords = c("lon", "lat"), crs = 4326)
# Calcular las distancias entre los apartamentos fuera de Chapinero y los CAIs
dist_matrix_cai <- st_distance(train_localidades_sf, cai_sf_bogota)
# Calcular la distancia mínima de cada apartamento a un CAI
dist_min_cai <- apply(dist_matrix_cai, 1, min)
# Agregar la distancia mínima a la base de datos
train_localidades_sf <- train_localidades_sf %>%
mutate(distancia_cai = dist_min_cai)
# Revisar los primeros resultados
head(train_localidades_sf)
View(train_localidades_sf)
# Convertir train_localidades a objeto sf directamente
train_localidades <- st_as_sf(train_localidades, coords = c("lon", "lat"), crs = 4326)
# Calcular las distancias entre los apartamentos fuera de Chapinero y los CAIs
dist_matrix_cai <- st_distance(train_localidades, cai_sf_bogota)
# Calcular la distancia mínima de cada apartamento a un CAI
dist_min_cai <- apply(dist_matrix_cai, 1, min)
# Agregar la distancia mínima a la base de datos
train_localidades <- train_localidades %>%
mutate(distancia_cai = dist_min_cai)
# Revisar resultados
head(train_localidades)
# Visualizar las distancias a los CAI
ggplot(train_localidades, aes(x = distancia_cai)) +
geom_histogram(bins = 50, fill = "darkred", alpha = 0.5) +
labs(x = "Distancia mínima a un CAI (m)", y = "Cantidad",
title = "Distribución de la distancia a los CAI en el resto de Bogotá") +
theme_bw()
# Guardar el gráfico
ggsave("../04_Views/GRAFICO8C-DISTANCIACAI_RESTO.png", dpi = 150, width = 8, height = 6)
# Obtener los límites de Bogotá
limites_bogota <- getbb("Bogotá, Colombia")
# Definir la consulta para estaciones/paradas de bus
bus_query_bogota <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "highway", value = "bus_stop")
# Descargar datos de paradas de bus
bus_data_bogota <- osmdata_sf(bus_query_bogota)
# Extraer los puntos de paradas de bus como objeto sf
bus_sf_bogota <- bus_data_bogota$osm_points %>%
dplyr::select(osm_id, name) %>%
st_transform(crs = 4326)  # Asegurar que esté en el mismo CRS que los apartamentos
# Verificar
head(bus_sf_bogota)
# Convertir train_localidades a sf si aún no lo está
train_localidades_sf <- st_as_sf(train_localidades, coords = c("lon", "lat"), crs = 4326)
# Calcular la matriz de distancias (en metros)
dist_matrix_bus <- st_distance(train_localidades_sf, bus_sf_bogota)
# Calcular la distancia mínima de cada apartamento a una parada de bus
dist_min_bus <- apply(dist_matrix_bus, 1, min)
# Agregar la distancia mínima como nueva variable
train_localidades <- train_localidades %>%
mutate(distancia_bus = dist_min_bus)
library(scales)
ggplot(train_localidades, aes(x = distancia_bus)) +
geom_histogram(bins = 50, fill = "steelblue", alpha = 0.6) +
labs(x = "Distancia mínima a una parada de bus (m)", y = "Cantidad",
title = "Distribución de la distancia a paradas de bus en el resto de Bogotá") +
scale_x_continuous(labels = comma) +
theme_bw()
# Guardar gráfico
ggsave("../04_Views/GRAFICO8D-DISTANCIABUS_RESTO.png", dpi = 150, width = 8, height = 6)
# Obtener los límites de Bogotá
limites_bogota <- getbb("Bogotá, Colombia")
# Crear consulta para avenidas principales
avenidas_query <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "highway",
value = c("motorway", "trunk", "primary", "secondary"))
# Descargar los datos
avenidas_data <- osmdata_sf(avenidas_query)
# Extraer las líneas (tramos viales)
avenidas_sf <- avenidas_data$osm_lines %>%
st_transform(crs = 4326)
# Asegúrate de que train_localidades es un objeto sf con CRS 4326
train_localidades_sf <- st_as_sf(train_localidades, coords = c("lon", "lat"), crs = 4326)
# Calcular distancias
dist_matrix_avenidas <- st_distance(train_localidades_sf, avenidas_sf)
View(train_localidades)
# Asegúrate de que train_localidades es un objeto sf con CRS 4326
train_localidades_sf <- st_as_sf(train_localidades, coords = c("lon", "lat"), crs = 4326)
# Calcular distancias
dist_matrix_avenidas <- st_distance(train_localidades_sf, avenidas_sf)
# Obtener los límites de Bogotá
limites_bogota <- getbb("Bogotá, Colombia")
# Crear consulta para avenidas principales
avenidas_query <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "highway",
value = c("motorway", "trunk", "primary", "secondary"))
# Descargar los datos
avenidas_data <- osmdata_sf(avenidas_query)
# Extraer las líneas (tramos viales)
avenidas_sf <- avenidas_data$osm_lines %>%
st_transform(crs = 4326)
# Extraer la distancia mínima a una avenida para cada punto
dist_min_avenida <- apply(dist_matrix_avenidas, 1, min)
# Calcular matriz de distancias entre puntos y líneas
dist_matrix_avenidas <- st_distance(train_localidades_sf, avenidas_sf)
# Asegúrate de que todo esté en sf y con el CRS correcto
train_localidades_sf <- st_as_sf(train_localidades, coords = c("lon", "lat"), crs = 4326)
avenidas_sf <- st_transform(avenidas_sf, crs = 4326)
# Encontrar el índice de la avenida más cercana a cada apartamento
idx_avenida_cercana <- st_nearest_feature(train_localidades_sf, avenidas_sf)
# Calcular la distancia real solo a esa avenida
dist_min_avenida <- st_distance(train_localidades_sf, avenidas_sf[idx_avenida_cercana, ], by_element = TRUE)
# Agregar a la base original
train_localidades$distancia_avenida <- as.numeric(dist_min_avenida)
# Verificar
summary(train_localidades$distancia_avenida)
ggplot(train_localidades, aes(x = distancia_avenida)) +
geom_histogram(bins = 50, fill = "darkblue", alpha = 0.6) +
labs(x = "Distancia mínima a una avenida principal (m)", y = "Cantidad",
title = "Distribución de la distancia a avenidas principales") +
theme_minimal()
# Guardar gráfico
ggsave("../04_Views/GRAFICO8D-DISTANCIAAVENIDA_RESTO.png", dpi = 150, width = 8, height = 6)
# Obtener límites de Bogotá
limites_bogota <- getbb("Bogotá, Colombia")
# Crear consulta para parques (landuse = grass, leisure = park)
parques_query <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "leisure", value = "park")
# Descargar los datos
parques_data <- osmdata_sf(parques_query)
# Extraer polígonos de parques
parques_sf <- parques_data$osm_polygons %>%
st_transform(crs = 4326)
# Asegurarse de que train_localidades es objeto sf
train_localidades_sf <- st_as_sf(train_localidades, coords = c("lon", "lat"), crs = 4326)
# Calcular distancias
dist_matrix_parques <- st_distance(train_localidades_sf, parques_sf)
# Calcular la distancia mínima a un parque
dist_min_parque <- apply(dist_matrix_parques, 1, min)
# Agregar la distancia a la base de datos
train_localidades$distancia_parque <- dist_min_parque
# Convertir train_localidades a un objeto sf (asegúrate de tener lon y lat en formato numérico)
train_localidades_sf <- st_as_sf(train_localidades, coords = c("lon", "lat"), crs = 4326)
# Crear un buffer de 500 metros alrededor de cada apartamento (esto reduce el área de consulta)
buffer_aptos <- st_buffer(train_localidades_sf, dist = 500)
# Nombre de las columnas de la base train_hogares
colnames(test_aptos)
# Seleccion de la columnas id de hogares
test_aptos %>%
select(property_id) %>%
head()
# Resumen de apartamentos de la base train_hogares
skim(test_aptos)
# Imputación de missing values con la media de train_aptos
## 1. Variable surface_total con mediana de train
test_aptos <- test_aptos  %>%
mutate(surface_total = ifelse(is.na(surface_total) == TRUE, mediana_surface_total, surface_total))
## 2. Variable surface_covered con mediana de train
test_aptos <- test_aptos  %>%
mutate(surface_covered = ifelse(is.na(surface_covered) == TRUE, mediana_surface_covered, surface_covered))
## 3.  Variable rooms con la moda de train
test_aptos <- test_aptos  %>%
mutate(rooms = ifelse(is.na(rooms) == TRUE, moda_rooms, rooms))
## 4.Variable bathrooms con moda de train
test_aptos <- test_aptos  %>%
mutate(bathrooms = ifelse(is.na(bathrooms) == TRUE, moda_bathrooms, bathrooms))
# Validación de correcta imputación de missing values en test
skim(test_aptos)
# Asegúrate de que test_aptos tenga coordenadas en formato espacial (sf)
test_aptos_sf <- st_as_sf(test_aptos, coords = c("lon", "lat"), crs = 4326)
# Calcular las distancias a parques (puedes hacer lo mismo para avenidas o CAIs)
# Distancias a parques
dist_matrix_parques <- st_distance(test_aptos_sf, parques_sf)
