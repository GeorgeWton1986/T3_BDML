# Cargar paquetes necesarios
library(sf)
library(dplyr)
library(osmdata)
library(leaflet)
# Paso 1: Convertir tu base con lat y lon a objeto espacial (sf)
# Asegúrate que las columnas se llamen exactamente "lon" y "lat"
train_sf <- st_as_sf(train_aptos, coords = c("lon", "lat"), crs = 4326)
# Paso 2: Descargar el polígono del barrio Chapinero desde OpenStreetMap
chapinero_barrio <- opq("Bogotá, Colombia") %>%
add_osm_feature(key = "name", value = "Chapinero") %>%
add_osm_feature(key = "place", value = c("neighbourhood", "suburb")) %>%
osmdata_sf()
# Paso 3: Extraer el polígono (intenta con polygons y multipolygons)
chapinero_shape <- chapinero_barrio$osm_polygons
if (nrow(chapinero_shape) == 0) {
chapinero_shape <- chapinero_barrio$osm_multipolygons
}
# Paso 4: Asegurar que ambos objetos tienen el mismo CRS
train_sf <- st_transform(train_sf, st_crs(chapinero_shape))
library(sf)
library(dplyr)
library(osmdata)
library(leaflet)
# Paso 1: Convertir tu base de apartamentos a objeto espacial con CRS 4326
train_sf <- st_as_sf(train_aptos, coords = c("lon", "lat"), crs = 4326)
# Paso 2: Descargar el polígono de Chapinero desde OSM
chapinero_barrio <- opq("Bogotá, Colombia") %>%
add_osm_feature(key = "name", value = "Chapinero") %>%
add_osm_feature(key = "place", value = c("neighbourhood", "suburb")) %>%
osmdata_sf()
# Paso 3: Tomar el polígono (polygons o multipolygons)
chapinero_shape <- chapinero_barrio$osm_polygons
if (nrow(chapinero_shape) == 0) {
chapinero_shape <- chapinero_barrio$osm_multipolygons
}
# ⚠️ Paso 4: Si el polígono NO tiene CRS, se lo asignamos explícitamente
if (is.na(st_crs(chapinero_shape))) {
st_crs(chapinero_shape) <- 4326
}
View(train_chapinero)
View(train_aptos)
# Cargar los paquetes necesarios
library(osmdata)
library(sf)
library(dplyr)
# Paso 1: Descargar el polígono del barrio Chapinero desde OpenStreetMap
chapinero_barrio <- opq("Bogotá, Colombia") %>%
add_osm_feature(key = "name", value = "Chapinero") %>%
add_osm_feature(key = "place", value = c("neighbourhood", "suburb")) %>%
osmdata_sf()
# Paso 2: Tomar el polígono del barrio (polygons o multipolygons)
chapinero_shape <- chapinero_barrio$osm_polygons
if (nrow(chapinero_shape) == 0) {
chapinero_shape <- chapinero_barrio$osm_multipolygons
}
# Paso 3: Convertir tu base de datos a objeto espacial
train_sf <- st_as_sf(train_aptos, coords = c("lon", "lat"), crs = 4326)
# Paso 4: Asegurarse de que ambos objetos tengan el mismo CRS
train_sf <- st_transform(train_sf, st_crs(chapinero_shape))
# Obtener el límite de coordenadas de Chapinero
limites <- getbb("Chapinero, Bogotá, Colombia")
limites
# Ampliamos un poco los límites para asegurarnos de no perder datos
train_chapinero <- train_aptos %>%
filter(
between(lon, limites[1, "min"] - 0.01, limites[1, "max"] + 0.01) &  # Ampliar el rango de longitud
between(lat, limites[2, "min"] - 0.01, limites[2, "max"] + 0.01)     # Ampliar el rango de latitud
)
# Ver cuántas observaciones quedaron
nrow(train_chapinero)
# Visualización en Leaflet
leaflet() %>%
addTiles() %>%
addCircles(lng = train_chapinero$lon,
lat = train_chapinero$lat)
# Instalar y cargar los paquetes necesarios si no están ya instalados
install.packages("leaflet")
library(leaflet)
# Paso 1: Obtener el polígono de Chapinero
limites_chapinero <- opq(bbox = getbb("Chapinero, Bogotá, Colombia")) %>%
add_osm_feature(key = "place", value = "suburb") %>%
osmdata_sf()
install.packages("leaflet")
# Instalar y cargar los paquetes necesarios si no están ya instalados
install.packages("leaflet")
library(leaflet)
# Paso 1: Obtener el polígono de Chapinero
limites_chapinero <- opq(bbox = getbb("Chapinero, Bogotá, Colombia")) %>%
add_osm_feature(key = "place", value = "suburb") %>%
osmdata_sf()
install.packages("leaflet")
# Instalar y cargar los paquetes necesarios si no están ya instalados
# Instalar los paquetes necesarios
install.packages("osmdata")
install.packages("sf")
install.packages("leaflet")
# Cargar los paquetes
library(osmdata)
library(sf)
library(leaflet)
# Paso 1: Obtener el polígono de Chapinero
limites_chapinero <- opq(bbox = getbb("Chapinero, Bogotá, Colombia")) %>%
add_osm_feature(key = "place", value = "suburb") %>%
osmdata_sf()
install.packages("leaflet")
# Asegurémonos de que las proyecciones sean coherentes
centroides_sf <- st_as_sf(centroides, coords = c("x", "y"), crs = 4326)
install.packages("sf")
library(sf)
# Asegurémonos de que las proyecciones sean coherentes
centroides_sf <- st_as_sf(centroides, coords = c("x", "y"), crs = 4326)
# Define el límite de Chapinero en Bogotá
limites_chapinero <- getbb("Chapinero, Bogotá, Colombia")
# Ahora solo nos quedaremos con las observaciones que efectivamente están dentro de Chapinero y no están mal georeferenciadas
limites <- getbb("Chapinero, Bogotá, Colombia")
# Instalar el paquete tmaptools si no está instalado
install.packages("tmaptools")
# Usar pacman para cargar (e instalar si es necesario) los paquetes
p_load(tidyverse,   # Manipulación y visualización de datos
dplyr,       # Manipulación de datos
ggplot2,     # Visualización de datos en gráficas
readr,       # Importación de datos
stargazer,   # Formato para tablas
utils,       # Lctura de archivos y manipulación de datos
skimr,       # Resumen estadístico
caret,       # Creación y validación de modelos predictivos
glmnet,      # Modelos de regresión penalizados (Ridge, Lasso)
xgboost,     # Implementación de Gradient Boosting
rpart,       # Árboles de decisión
rpart.plot,  # Visualización de árboles generados por rpart
pROC,        # Curvas ROC y métricas
Metrics,     # Métricas de evaluación
httr,        # Solicitudes http
rio,         # Facilidad para importar data
plotly,      # Gráficos interactivos
osmdata,     # Obtener información de open street maps
sf,          # Leer/escribir/manipular datos espaciales
leaflet,     # Mapas interactivos
gridExtra,   # Graficar en grid
tmaptools,   # Geocode_OMS()
geosphere   # Calcular distancias geográficas como Haversine
)
# Instalar y cargar el paquetes
if (!require("pacman")) install.packages("pacman")
library(pacman)
if (!require("MLmetrics")) install.packages("MLmetrics")
library(MLmetrics)
# Usar pacman para cargar (e instalar si es necesario) los paquetes
p_load(tidyverse,   # Manipulación y visualización de datos
dplyr,       # Manipulación de datos
ggplot2,     # Visualización de datos en gráficas
readr,       # Importación de datos
stargazer,   # Formato para tablas
utils,       # Lctura de archivos y manipulación de datos
skimr,       # Resumen estadístico
caret,       # Creación y validación de modelos predictivos
glmnet,      # Modelos de regresión penalizados (Ridge, Lasso)
xgboost,     # Implementación de Gradient Boosting
rpart,       # Árboles de decisión
rpart.plot,  # Visualización de árboles generados por rpart
pROC,        # Curvas ROC y métricas
Metrics,     # Métricas de evaluación
httr,        # Solicitudes http
rio,         # Facilidad para importar data
plotly,      # Gráficos interactivos
osmdata,     # Obtener información de open street maps
sf,          # Leer/escribir/manipular datos espaciales
leaflet,     # Mapas interactivos
gridExtra,   # Graficar en grid
tmaptools,   # Geocode_OMS()
geosphere   # Calcular distancias geográficas como Haversine
)
# Ahora solo nos quedaremos con las observaciones que efectivamente están dentro de Chapinero y no están mal georeferenciadas
limites <- getbb("Chapinero, Bogotá, Colombia")
limites
train_chapinero <- train_aptos %>%
filter(
between(lon, limites[1, "min"], limites[1, "max"]) &
between(lat, limites[2, "min"], limites[2, "max"])
)
leaflet() %>%
addTiles() %>%
addCircles(lng = train_chapinero$lon,
lat = train_chapinero$lat)
# Define el límite de Chapinero en Bogotá
limites_chapinero <- getbb("Chapinero, Bogotá, Colombia")
# Extrae la información de los parques en Chapinero
parques_chapinero <- opq(bbox = limites_chapinero) %>%
add_osm_feature(key = "leisure", value = "park")
# Convierte los datos a formato sf
parques_sf_chapinero <- osmdata_sf(parques_chapinero)
# Filtra los parques dentro del límite de Chapinero
parques_chapinero_geometria <- parques_sf_chapinero$osm_polygons %>%
dplyr::select(osm_id, name)
# Verifica los parques en Chapinero
leaflet() %>%
addTiles() %>%
addPolygons(data = parques_chapinero_geometria, color = "red", weight = 2, opacity = 0.8, popup = parques_chapinero_geometria$name)
# Calcula los centroides de los parques en Chapinero
centroides_chapinero <- st_centroid(parques_chapinero_geometria, byid = TRUE)
# Extrae las coordenadas de los centroides
centroides_chapinero <- centroides_chapinero %>%
mutate(x = st_coordinates(centroides_chapinero)[, "X"]) %>%
mutate(y = st_coordinates(centroides_chapinero)[, "Y"])
# Convertimos los centroides a un objeto sf
centroides_chapinero_sf <- st_as_sf(centroides_chapinero, coords = c("x", "y"), crs = 4326)
# Visualiza los centroides
leaflet() %>%
addTiles() %>%
addCircles(data = centroides_chapinero_sf, color = "darkblue", radius = 50, opacity = 0.7)
# Asegúrate de que los apartamentos también están en formato sf y con la proyección adecuada
sf_aptos <- st_as_sf(train_chapinero, coords = c("lon", "lat"), crs = 4326)
# Calcula la distancia entre cada apartamento y los centroides de los parques
distancias <- st_distance(sf_aptos, centroides_chapinero_sf)
# Si deseas obtener la distancia más cercana a un parque para cada apartamento:
distancia_minima <- apply(distancias, 1, min)
# Añadir la distancia mínima como una nueva variable
train_chapinero$distancia_parque <- distancia_minima
# Visualizar la distribución de las distancias
hist(train_chapinero$distancia_parque)
# Calcular la distancia entre los apartamentos y los centroides de los parques
dist_matrix <- st_distance(sf_aptos, centroides_chapinero_sf)
# Obtener la distancia mínima para cada apartamento
dist_min <- apply(dist_matrix, 1, min)
# Añadir la distancia mínima a la base de datos original
db <- db %>% mutate(distancia_parque = dist_min)
# Convertir los apartamentos a un objeto sf (esto estaba faltando en tu código)
sf_aptos <- st_as_sf(train_chapinero, coords = c("lon", "lat"), crs = 4326)
# Calcular la distancia entre los apartamentos y los centroides de los parques
dist_matrix <- st_distance(sf_aptos, centroides_chapinero_sf)
# Obtener la distancia mínima para cada apartamento
dist_min <- apply(dist_matrix, 1, min)
# Añadir la distancia mínima a la base de datos de los apartamentos
train_chapinero <- train_chapinero %>% mutate(distancia_parque = dist_min)
# Crear el histograma de la distancia mínima a los parques
p <- ggplot(train_chapinero, aes(x = distancia_parque)) +
geom_histogram(bins = 50, fill = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros", y = "Cantidad",
title = "Distribución de la distancia a los parques en Chapinero") +
theme_bw()
# Convertir el gráfico a interactivo con plotly
ggplotly(p)
View(train_chapinero)
# Convertir los apartamentos a un objeto sf
sf_aptos <- st_as_sf(train_chapinero, coords = c("lon", "lat"), crs = 4326)
# Calcular la distancia entre los apartamentos y los centroides de los parques
dist_matrix <- st_distance(sf_aptos, centroides_chapinero_sf)
# Obtener la distancia mínima para cada apartamento
dist_min <- apply(dist_matrix, 1, min)
# Añadir la distancia mínima a la base de datos de los apartamentos
train_chapinero <- train_chapinero %>% mutate(distancia_parque = dist_min)
# Crear el histograma de la distancia mínima a los parques
p <- ggplot(train_chapinero, aes(x = distancia_parque)) +
geom_histogram(bins = 50, fill = "darkblue", alpha = 0.4) +
labs(x = "Distancia mínima a un parque en metros", y = "Cantidad",
title = "Distribución de la distancia a los parques en Chapinero") +
theme_bw()
ggsave("../04_Views/GRAFICO8-DISTANCIAPARQUES.png", plot = p, dpi = 150, width = 8, height = 6)
# Definir el área de Chapinero
limites_chapinero <- getbb("Chapinero, Bogotá, Colombia")
# Descargar estaciones de TransMilenio (usualmente etiquetadas como 'bus_station' o 'platform')
transmi_query <- opq(bbox = limites_chapinero) %>%
add_osm_feature(key = "public_transport", value = "platform") %>%
add_osm_feature(key = "bus", value = "yes", value_exact = FALSE)
# Obtener datos como sf
transmi_data <- osmdata_sf(transmi_query)
# Usar puntos de plataformas si están disponibles
transmi_sf <- transmi_data$osm_points %>%
dplyr::select(osm_id, name)
# Verificar
leaflet() %>%
addTiles() %>%
addCircles(data = transmi_sf, color = "red", radius = 50, label = ~name)
# Convertir estaciones a sf si no lo son
transmi_sf <- st_as_sf(transmi_sf)
# Asegurar que ambos están en la misma proyección
train_chapinero_sf <- st_as_sf(train_chapinero, coords = c("lon", "lat"), crs = 4326)
train_chapinero_sf <- st_transform(train_chapinero_sf, 4326)
transmi_sf <- st_transform(transmi_sf, 4326)
# Calcular matriz de distancias
dist_matrix_transmi <- st_distance(train_chapinero_sf, transmi_sf)
# Obtener la distancia mínima a estación TransMilenio
dist_min_transmi <- apply(dist_matrix_transmi, 1, min)
# Agregarla a la base original
train_chapinero <- train_chapinero %>%
mutate(distancia_transmi = dist_min_transmi)
View(train_chapinero)
# Obtener bbox de Chapinero
limites_chapinero <- getbb("Chapinero, Bogotá, Colombia")
# Obtener CAI (policías)
cai_query <- opq(bbox = limites_chapinero) %>%
add_osm_feature(key = "amenity", value = "police")
cai_data <- osmdata_sf(cai_query)
cai_sf <- cai_data$osm_points %>% dplyr::select(osm_id, name)
cai_sf <- st_transform(cai_sf, 4326)
# Convertir apartamentos a sf si no lo están
aptos_sf <- st_as_sf(train_chapinero, coords = c("lon", "lat"), crs = 4326)
# Calcular distancias
dist_matrix_cai <- st_distance(aptos_sf, cai_sf)
dist_min_cai <- apply(dist_matrix_cai, 1, min)
# Agregar a la base
train_chapinero <- train_chapinero %>%
mutate(distancia_cai = dist_min_cai)
# Obtener vías principales en Chapinero
vias_query <- opq(bbox = limites_chapinero) %>%
add_osm_feature(key = "highway", value = c("primary", "trunk"))
vias_data <- osmdata_sf(vias_query)
vias_sf <- vias_data$osm_lines %>% dplyr::select(osm_id, name)
vias_sf <- st_transform(vias_sf, 4326)
# Calcular distancia a la vía principal más cercana
dist_matrix_vias <- st_distance(aptos_sf, vias_sf)
dist_min_vias <- apply(dist_matrix_vias, 1, min)
# Agregar a la base
train_chapinero <- train_chapinero %>%
mutate(distancia_via_principal = dist_min_vias)
View(train_chapinero)
View(train_chapinero)
View(train_sf)
View(train_chapinero)
View(train_aptos)
# Instalar y cargar el paquetes
if (!require("pacman")) install.packages("pacman")
library(pacman)
if (!require("MLmetrics")) install.packages("MLmetrics")
library(MLmetrics)
# Usar pacman para cargar (e instalar si es necesario) los paquetes
p_load(tidyverse,   # Manipulación y visualización de datos
dplyr,       # Manipulación de datos
ggplot2,     # Visualización de datos en gráficas
readr,       # Importación de datos
stargazer,   # Formato para tablas
utils,       # Lctura de archivos y manipulación de datos
skimr,       # Resumen estadístico
caret,       # Creación y validación de modelos predictivos
glmnet,      # Modelos de regresión penalizados (Ridge, Lasso)
xgboost,     # Implementación de Gradient Boosting
rpart,       # Árboles de decisión
rpart.plot,  # Visualización de árboles generados por rpart
pROC,        # Curvas ROC y métricas
Metrics,     # Métricas de evaluación
httr,        # Solicitudes http
rio,         # Facilidad para importar data
plotly,      # Gráficos interactivos
osmdata,     # Obtener información de open street maps
sf,          # Leer/escribir/manipular datos espaciales
leaflet,     # Mapas interactivos
gridExtra,   # Graficar en grid
tmaptools,   # Geocode_OMS()
geosphere   # Calcular distancias geográficas como Haversine
)
# 1. Carga de datos train
## Definir URL del archivo Excel en GitHub
url_excel_train <- "https://raw.githubusercontent.com/GeorgeWton1986/T3_BDML/refs/heads/main/03_Stores/train.csv"
## Descargar el archivo temporalmente
temp_file <- tempfile(fileext = ".csv")
GET(url_excel_train, write_disk(temp_file, overwrite = TRUE))
## Leer el archivo CSV en un dataframe
train_aptos <- read_csv(temp_file)
# 2. Carga de datos test hogares
## Definir URL del archivo Excel en GitHub
url_excel_test <- "https://raw.githubusercontent.com/GeorgeWton1986/T3_BDML/refs/heads/main/03_Stores/test.csv"
## Descargar el archivo temporalmente
temp_file <- tempfile(fileext = ".csv")
GET(url_excel_test, write_disk(temp_file, overwrite = TRUE))
# Leer el archivo CSV en un dataframe
test_aptos <- read_csv(temp_file)
# 1. Carga de datos train
## Definir URL del archivo Excel en GitHub
url_excel_train <- "https://raw.githubusercontent.com/GeorgeWton1986/T3_BDML/refs/heads/main/03_Stores/train.csv"
## Descargar el archivo temporalmente
temp_file <- tempfile(fileext = ".csv")
GET(url_excel_train, write_disk(temp_file, overwrite = TRUE))
## Leer el archivo CSV en un dataframe
train_aptos <- read_csv(temp_file)
# 2. Carga de datos test hogares
## Definir URL del archivo Excel en GitHub
url_excel_test <- "https://raw.githubusercontent.com/GeorgeWton1986/T3_BDML/refs/heads/main/03_Stores/test.csv"
## Descargar el archivo temporalmente
temp_file <- tempfile(fileext = ".csv")
GET(url_excel_test, write_disk(temp_file, overwrite = TRUE))
# Leer el archivo CSV en un dataframe
test_aptos <- read_csv(temp_file)
# Nombre de las columnas de la base train_hogares
colnames(train_aptos)
# Seleccion de la columnas id de hogares
train_aptos %>%
select(property_id) %>%
head()
# Resumen de apartamentos de la base train_hogares
skim(train_aptos)
# Tratamiento de missing values
train_miss <- skim(train_aptos) %>%
filter(skim_type == "numeric") %>%
select(skim_variable, n_missing)
nobs_train <- nrow(train_aptos)
# Porcentaje de missing
train_aptos_miss<- train_miss %>%
mutate(p_missing= n_missing/nobs_train) %>%
filter(n_missing!= 0) %>%
arrange(-n_missing)
train_aptos_miss
# Visualizar variables con missing values
## Gráfico para surface_total (área total)
graf_ms1 <- ggplot(train_aptos, aes(surface_total)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
geom_vline(xintercept = median(train_aptos$surface_total, na.rm = TRUE), linetype = "dashed", color = "red") +
geom_vline(xintercept = mean(train_aptos$surface_total, na.rm = TRUE), linetype = "dashed", color = "blue") +
ggtitle("GRÁFICA 1 - Área total") +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO1-HISTOGRAMA-AREATOTAL.png", plot = graf_ms1, dpi = 150, width = 8, height = 6)
## Gráfico para surface_covered (área privada)
graf_ms2 <- ggplot(train_aptos, aes(surface_covered)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
geom_vline(xintercept = median(train_aptos$surface_covered, na.rm = TRUE), linetype = "dashed", color = "red") +
geom_vline(xintercept = mean(train_aptos$surface_covered, na.rm = TRUE), linetype = "dashed", color = "blue") +
ggtitle("GRÁFICA 2 - Área privada") +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO2-HISTOGRAMA-AREAPRIVADA.png", plot = graf_ms2, dpi = 150, width = 8, height = 6)
## Gráfico para rooms (habitaciones)
graf_ms3 <- ggplot(train_aptos, aes(rooms)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
geom_vline(xintercept = median(train_aptos$rooms, na.rm = TRUE), linetype = "dashed", color = "red") +
geom_vline(xintercept = mean(train_aptos$rooms, na.rm = TRUE), linetype = "dashed", color = "blue") +
ggtitle("GRÁFICA 3 -Habitaciones") +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO3-HISTOGRAMA-HABITACIONES.png", plot = graf_ms3, dpi = 150, width = 8, height = 6)
## Gráfico para bathrooms (baños)
graf_ms4 <- ggplot(train_aptos, aes(bathrooms)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
geom_vline(xintercept = median(train_aptos$bathrooms, na.rm = TRUE), linetype = "dashed", color = "red") +
geom_vline(xintercept = mean(train_aptos$bathrooms, na.rm = TRUE), linetype = "dashed", color = "blue") +
ggtitle("GRÁFICA 4 - Baños") +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO4-HISTOGRAMA-BAÑOS.png", plot = graf_ms4, dpi = 150, width = 8, height = 6)
# Imputación de variables con la mediana y moda
## 1. Variable surface_total con mediana
mediana_surface_total <- median(train_aptos$surface_total, na.rm = TRUE)
train_aptos <- train_aptos  %>%
mutate(surface_total = ifelse(is.na(surface_total) == TRUE, mediana_surface_total, surface_total))
## 2. Variable surface_covered con mediana
mediana_surface_covered <- median(train_aptos$surface_covered, na.rm = TRUE)
train_aptos <- train_aptos  %>%
mutate(surface_covered = ifelse(is.na(surface_covered) == TRUE, mediana_surface_covered, surface_covered))
## 3.  Variable rooms con la moda
moda_rooms <- train_aptos %>%
filter(!is.na(rooms)) %>%
count(rooms) %>%
arrange(desc(n)) %>%
slice(1) %>%
pull(rooms)
train_aptos <- train_aptos  %>%
mutate(rooms = ifelse(is.na(rooms) == TRUE, moda_rooms, rooms))
## 4.Variable bathrooms con la moda
moda_bathrooms <- train_aptos %>%
filter(!is.na(bathrooms)) %>%
count(bathrooms) %>%
arrange(desc(n)) %>%
slice(1) %>%
pull(bathrooms)
train_aptos <- train_aptos  %>%
mutate(bathrooms = ifelse(is.na(bathrooms) == TRUE, moda_bathrooms, bathrooms))
# Validación de correcta imputación de missing values en variables numéricas
skim(train_aptos)
train_aptos <- as.data.frame(train_aptos)
stargazer(train_aptos, type = "text")
# Calcular el precio por metro cuadrado
train_aptos <- train_aptos %>%
mutate(precio_mt2 = round(price / surface_total, 0))
skim(train_aptos)
# Histograma del precio por metro cuadrado
graf_5 <- ggplot(train_aptos, aes(precio_mt2)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
ggtitle("GRÁFICA 4 - Precio por metro cuadrado (millones)") +
scale_x_continuous(labels = function(x) x / 1e6) +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO5-HISTOGRAMA-PRECIOXMETROCUADRADO.png", plot = graf_5, dpi = 150, width = 8, height = 6)
# Box plot del precio por metro cuadrado
graf_6 <- train_aptos %>%
ggplot(aes(y = precio_mt2)) +
geom_boxplot(fill = "darkblue", alpha = 0.4) +
labs(
title = "Muestra completa",
y = "Precio por metro cuadrado (millones)", x = "") +
scale_y_continuous(labels = function(x) x / 1e6) +
theme_bw()
ggsave("../04_Views/GRAFICO6-BOXPLOT-PRECIOXMETROCUADRADO.png", plot = graf_6, dpi = 150, width = 8, height = 6)
# Ante outliers superiores se aplica la Metodología de percentil 99%
#p1 <- quantile(train_aptos$precio_mt2, probs = 0.01, na.rm = TRUE)
p99 <- quantile(train_aptos$precio_mt2, probs = 0.99, na.rm = TRUE)
train_aptos <- train_aptos %>%
filter(precio_mt2 <= p99)
# Filtrar solo los valores menores o iguales al límite superior
graf_7 <- train_aptos %>%
ggplot(aes(y = precio_mt2)) +
geom_boxplot(fill = "darkblue", alpha = 0.4) +
labs(
title = "Muestra filtrada - P99",
y = "Precio por metro cuadrado (millones)", x = "") +
scale_y_continuous(labels = function(x) x / 1e6) +
theme_bw()
ggsave("../04_Views/GRAFICO6-BOXPLOT-PRECIOXMETROCUADRADO-P99.png", plot = graf_7, dpi = 150, width = 8, height = 6)
# Observamos la primera visualización de la ubicación de los inmubles de la base train_aptos
leaflet() %>%
addTiles() %>%
addCircles(lng = train_aptos$lon,
lat = train_aptos$lat)
