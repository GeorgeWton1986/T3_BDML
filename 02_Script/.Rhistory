ggtitle("GRÁFICA 4 - Baños") +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO4-HISTOGRAMA-BAÑOS.png", plot = graf_ms4, dpi = 150, width = 8, height = 6)
# Imputación de variables con la mediana y moda
## 1. Variable surface_total con mediana
mediana_surface_total <- median(train_aptos$surface_total, na.rm = TRUE)
train_aptos <- train_aptos  %>%
mutate(surface_total = ifelse(is.na(surface_total) == TRUE, mediana_surface_total, surface_total))
## 2. Variable surface_covered con mediana
mediana_surface_covered <- median(train_aptos$surface_covered, na.rm = TRUE)
train_aptos <- train_aptos  %>%
mutate(surface_covered = ifelse(is.na(surface_covered) == TRUE, mediana_surface_covered, surface_covered))
## 3.  Variable rooms con la moda
moda_rooms <- train_aptos %>%
filter(!is.na(rooms)) %>%
count(rooms) %>%
arrange(desc(n)) %>%
slice(1) %>%
pull(rooms)
train_aptos <- train_aptos  %>%
mutate(rooms = ifelse(is.na(rooms) == TRUE, moda_rooms, rooms))
## 4.Variable bathrooms con la moda
moda_bathrooms <- train_aptos %>%
filter(!is.na(bathrooms)) %>%
count(bathrooms) %>%
arrange(desc(n)) %>%
slice(1) %>%
pull(bathrooms)
train_aptos <- train_aptos  %>%
mutate(bathrooms = ifelse(is.na(bathrooms) == TRUE, moda_bathrooms, bathrooms))
# Validación de correcta imputación de missing values en variables numéricas
skim(train_aptos)
train_aptos <- as.data.frame(train_aptos)
stargazer(train_aptos, type = "text")
# Calcular el precio por metro cuadrado
train_aptos <- train_aptos %>%
mutate(precio_mt2 = round(price / surface_total, 0))
skim(train_aptos)
# Histograma del precio por metro cuadrado
graf_5 <- ggplot(train_aptos, aes(precio_mt2)) +
geom_histogram(color = "#000000", fill = "#0099F8") +
ggtitle("GRÁFICA 4 - Precio por metro cuadrado (millones)") +
scale_x_continuous(labels = function(x) x / 1e6) +
theme_bw() +
theme(plot.title = element_text(size = 18))
ggsave("../04_Views/GRAFICO5-HISTOGRAMA-PRECIOXMETROCUADRADO.png", plot = graf_5, dpi = 150, width = 8, height = 6)
# Box plot del precio por metro cuadrado
graf_6 <- train_aptos %>%
ggplot(aes(y = precio_mt2)) +
geom_boxplot(fill = "darkblue", alpha = 0.4) +
labs(
title = "Muestra completa",
y = "Precio por metro cuadrado (millones)", x = "") +
scale_y_continuous(labels = function(x) x / 1e6) +
theme_bw()
ggsave("../04_Views/GRAFICO6-BOXPLOT-PRECIOXMETROCUADRADO.png", plot = graf_6, dpi = 150, width = 8, height = 6)
# Ante outliers superiores se aplica la Metodología de percentil 99%
#p1 <- quantile(train_aptos$precio_mt2, probs = 0.01, na.rm = TRUE)
p99 <- quantile(train_aptos$precio_mt2, probs = 0.99, na.rm = TRUE)
train_aptos <- train_aptos %>%
filter(precio_mt2 <= p99)
# Filtrar solo los valores menores o iguales al límite superior
graf_7 <- train_aptos %>%
ggplot(aes(y = precio_mt2)) +
geom_boxplot(fill = "darkblue", alpha = 0.4) +
labs(
title = "Muestra filtrada - P99",
y = "Precio por metro cuadrado (millones)", x = "") +
scale_y_continuous(labels = function(x) x / 1e6) +
theme_bw()
ggsave("../04_Views/GRAFICO6-BOXPLOT-PRECIOXMETROCUADRADO-P99.png", plot = graf_7, dpi = 150, width = 8, height = 6)
# Observamos la primera visualización de la ubicación de los inmubles de la base train_aptos
leaflet() %>%
addTiles() %>%
addCircles(lng = train_aptos$lon,
lat = train_aptos$lat)
# Columas númericas
train_aptos <- train_aptos %>%
mutate(lon = as.numeric(lon), lat = as.numeric(lat))
limite_chapinero <- getbb("Chapinero, Bogotá, Colombia")
# Las coordenadas en EPSG:4326
train_aptos_sf <- st_as_sf(train_aptos,
coords = c("lon", "lat"),
crs = 4326)
# Filtrar límites sin chapinero
train_localidades <- train_aptos %>%
filter(
lon < limite_chapinero[1, "min"] | lon > limite_chapinero[1, "max"] |
lat < limite_chapinero[2, "min"] | lat > limite_chapinero[2, "max"]
)
#Train_localicadades NO incluye chapinero
train_localidades_sf <- st_as_sf(train_localidades,
coords = c("lon", "lat"),
crs = 4326)
# Visualizar
leaflet() %>%
addTiles() %>%
addCircles(lng = train_localidades$lon,
lat = train_localidades$lat)
train_localidades_tokens_clean %>%
count(word, sort = TRUE)
library(tidytext)
library(dplyr)
# Tokenización de la columna 'description'
train_localidades_tokens <- train_localidades %>%
unnest_tokens(word, description)
#Quitar stop words
data("stop_words")
train_localidades_tokens_clean <- train_localidades_tokens %>%
anti_join(stop_words)
train_localidades_tokens_clean %>%
count(word, sort = TRUE)
library(dplyr)
#Vector palabras agrupadas
parking <- c("parqueadero", "garaje", "parqueaderos", "garajes")
terrace <- c("terraza", "balcon")
gym <- "gimnasio"
laundry <- "lavanderia"
elevator <- "ascensor"
#Variable dummy para cada caracteristica
dummies_df <- train_localidades_tokens_clean %>%
mutate(binaria_parking = word %in% parking,
binaria_terrace = word %in% terrace,
binaria_gym = word %in% gym,
binaria_laundry = word %in% laundry,
binaria_elevator = word %in% elevator) %>%
group_by(property_id) %>%
summarise(across(starts_with("binaria_"), ~as.integer(any(.))))
# Unir a df
train_localidades <- left_join(train_localidades, dummies_df, by = "property_id")
# Obtener los límites de Bogotá
limites_bogota <- getbb("Bogotá, Colombia")
mall_bogota <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "shop",
value = "mall")
# Descargar datos de Mall
mall_data_bogota <- osmdata_sf(mall_bogota)
# Extraer los puntos de los parques en Bogotá como un objeto sf
mall_sf_bogota <- mall_data_bogota$osm_points %>%
dplyr::select(osm_id, name) %>%
st_transform(crs = 4326)  # Asegurarse de que el CRS coincida con el de los apartamentos
# Revisar los datos de los parques
head(mall_sf_bogota)
#¡¡¡IMPORTANTE!!!!
#(MAGNA-SIRGAS / Colombia Bogota)
# Localidades - Transformar a un sistema de coordenadas proyectado para Colombia
train_localidades_metros <- st_transform(train_localidades_sf,
crs = 3116)
print(train_localidades_metros)
# Parques - Transformar a un sistema de coordenadas proyectado para Colombia
train_mall_metros <- st_transform(mall_sf_bogota,
crs = 3116)
print(train_mall_metros)
# Calcular las distancias entre los apartamentos y los parques
dist_matrix_mall <- st_distance(train_localidades_metros, train_mall_metros)
# Calcular la distancia mínima a un parque para cada apartamento
dist_min_mall <- apply(dist_matrix_mall, 1, min)
# Agregar la distancia mínima a la base de datos train_localidades
train_localidades_metros$distancia_mall <- as.numeric(dist_min_mall)
# Agregar la distancia mínima a la base de datos
train_localidades <- train_localidades %>%
mutate(distancia_mall = dist_min_mall)
# Revisar resultados
head(train_localidades)
# Crear histograma
p2 <- ggplot(train_localidades, aes(x = distancia_mall)) +
geom_histogram(bins = 50, fill = "darkgreen", alpha = 0.5) +
labs(x = "Distancia mínima hasta el Mall(m)", y = "Cantidad",
title = "Distribución de distancia a Mall - resto de Bogotá") +
theme_bw()
ggsave("../04_Views/GRAFICO8B-DISTANCIAMALL_RESTO.png", plot = p2, dpi = 150, width = 8, height = 6)
# Obtener los CAIs (estaciones de policía) en Bogotá desde OSM
cai_bogota <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "amenity", value = "police")
# Descargar datos de Cai
cai_data_bogota <- osmdata_sf(cai_bogota)
# Extraer los puntos de los parques en Bogotá como un objeto sf
cai_sf_bogota <- cai_data_bogota$osm_points %>%
dplyr::select(osm_id, name) %>%
st_transform(crs = 4326)  # Asegurarse de que el CRS coincida con el de los apartamentos
# Revisar los datos de los CAI's
head(cai_sf_bogota)
#¡¡¡IMPORTANTE!!!!
#(MAGNA-SIRGAS / Colombia Bogota)
# Localidades - Transformar a un sistema de coordenadas proyectado para Colombia
train_localidades_metros <- st_transform(train_localidades_sf,
crs = 3116)
print(train_localidades_metros)
# Parques - Transformar a un sistema de coordenadas proyectado para Colombia
train_cai_metros <- st_transform(cai_sf_bogota,
crs = 3116)
print(train_cai_metros)
# Calcular las distancias entre los apartamentos y los parques
dist_matrix_cai <- st_distance(train_localidades_metros, train_cai_metros)
# Calcular la distancia mínima a un parque para cada apartamento
dist_min_cai <- apply(dist_matrix_cai, 1, min)
# Agregar la distancia mínima a la base de datos train_localidades
train_localidades_metros$distancia_cai <- as.numeric(dist_min_cai)
# Agregar la distancia mínima a la base de datos
train_localidades <- train_localidades %>%
mutate(distancia_cai = dist_min_cai)
# Revisar resultados
head(train_localidades)
# Visualizar las distancias a los CAI
ggplot(train_localidades, aes(x = distancia_cai)) +
geom_histogram(bins = 50, fill = "darkred", alpha = 0.5) +
labs(x = "Distancia mínima a un CAI (m)", y = "Cantidad",
title = "Distribución de la distancia a los CAI en el resto de Bogotá") +
theme_bw()
# Guardar el gráfico
ggsave("../04_Views/GRAFICO8C-DISTANCIACAI_RESTO.png", dpi = 150, width = 8, height = 6)
# 1. Obtener las paradas de bus en Bogotá desde OSM
bus_stop_bogota <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "highway", value = "bus_stop")
# 2. Descargar los datos
bus_stop_data <- osmdata_sf(bus_stop_bogota)
# 3. Extraer los puntos como objeto sf
bus_stop_sf <- bus_stop_data$osm_points %>%
dplyr::select(osm_id, name) %>%
st_transform(crs = 4326)
# 4. Transformar las capas al sistema de coordenadas proyectado (MAGNA-SIRGAS)
train_localidades_metros <- st_transform(train_localidades_sf, crs = 3116)
bus_stop_metros <- st_transform(bus_stop_sf, crs = 3116)
# 5. Calcular matriz de distancias entre localidades y paradas de bus
dist_matrix_bus <- st_distance(train_localidades_metros, bus_stop_metros)
# 6. Calcular la distancia mínima a una parada de bus
dist_min_bus <- apply(dist_matrix_bus, 1, min)
# 7. Agregar a la base de datos
train_localidades_metros$distancia_bus <- as.numeric(dist_min_bus)
# 8. Agregar a train_localidades (si aún trabajas con versión en CRS 4326)
train_localidades <- train_localidades %>%
mutate(distancia_bus = dist_min_bus)
# 9. Revisar resultados
head(train_localidades)
library(scales)
ggplot(train_localidades, aes(x = distancia_bus)) +
geom_histogram(bins = 50, fill = "steelblue", alpha = 0.6) +
labs(x = "Distancia mínima a una parada de bus (m)", y = "Cantidad",
title = "Distribución de la distancia a paradas de bus en el resto de Bogotá") +
scale_x_continuous(labels = comma) +
theme_bw()
# Guardar gráfico
ggsave("../04_Views/GRAFICO8D-DISTANCIABUS_RESTO.png", dpi = 150, width = 8, height = 6)
# 1. Obtener avenidas principales en Bogotá desde OSM
avenidas_bogota <- opq(bbox = limites_bogota) %>%
add_osm_feature(key = "highway",
value = "primary")
# 2. Descargar los datos
avenidas_data <- osmdata_sf(avenidas_bogota)
# 3. Extraer las líneas (vías suelen estar como `osm_lines`)
avenidas_sf <- avenidas_data$osm_lines %>%
dplyr::select(osm_id, name, highway) %>%
st_transform(crs = 4326)
# 4. Transformar al sistema proyectado para cálculo de distancias
avenidas_metros <- st_transform(avenidas_sf, crs = 3116)
train_localidades_metros <- st_transform(train_localidades_sf, crs = 3116)
# 5. Calcular la distancia de cada punto a la vía más cercana
dist_matrix_avenidas <- st_distance(train_localidades_metros, avenidas_metros)
# 6. Distancia mínima a una avenida para cada punto
dist_min_avenida <- apply(dist_matrix_avenidas, 1, min)
# 7. Agregar a la base de datos
train_localidades_metros$distancia_avenida <- as.numeric(dist_min_avenida)
train_localidades <- train_localidades %>%
mutate(distancia_avenida = dist_min_avenida)
# 8. Revisar resultados
head(train_localidades)
#1. Verificar y asegurar que sea un objeto espacial con CRS 3116
if(!inherits(train_localidades, "sf")) {
train_localidades_sf <- st_as_sf(
train_localidades,
coords = c("lon", "lat"),
crs = 3116
)
} else {
train_localidades_sf <- train_localidades
}
#2. Verificar el CRS este correcto
print(st_crs(train_localidades_sf))
ggplot(train_localidades, aes(x = distancia_avenida)) +
geom_histogram(bins = 50, fill = "darkblue", alpha = 0.6) +
labs(x = "Distancia mínima a una avenida principal (m)", y = "Cantidad",
title = "Distribución de la distancia a avenidas principales") +
theme_minimal()
# Guardar gráfico
ggsave("../04_Views/GRAFICO8D-DISTANCIAAVENIDA_RESTO.png", dpi = 150, width = 8, height = 6)
# Nombre de las columnas de la base train_hogares
colnames(test_aptos)
# Seleccion de la columnas id de hogares
test_aptos %>%
select(property_id) %>%
head()
# Resumen de apartamentos de la base train_hogares
skim(test_aptos)
# Imputación de missing values con la media de train_aptos
## 1. Variable surface_total con mediana de train
test_aptos <- test_aptos  %>%
mutate(surface_total = ifelse(is.na(surface_total) == TRUE, mediana_surface_total, surface_total))
## 2. Variable surface_covered con mediana de train
test_aptos <- test_aptos  %>%
mutate(surface_covered = ifelse(is.na(surface_covered) == TRUE, mediana_surface_covered, surface_covered))
## 3.  Variable rooms con la moda de train
test_aptos <- test_aptos  %>%
mutate(rooms = ifelse(is.na(rooms) == TRUE, moda_rooms, rooms))
## 4.Variable bathrooms con moda de train
test_aptos <- test_aptos  %>%
mutate(bathrooms = ifelse(is.na(bathrooms) == TRUE, moda_bathrooms, bathrooms))
# Validación de correcta imputación de missing values en test
skim(test_aptos)
# Asegurarte de que lon y lat sean numéricos
test_aptos <- test_aptos %>%
mutate(lon = as.numeric(lon), lat = as.numeric(lat))
# Obtener límites de Chapinero
limite_chapinero <- getbb("Chapinero, Bogotá, Colombia")
# Filtrar SOLO los que están dentro de Chapinero
test_chapinero <- test_aptos %>%
filter(
between(lon, limite_chapinero[1, "min"], limite_chapinero[1, "max"]) &
between(lat, limite_chapinero[2, "min"], limite_chapinero[2, "max"])
)
# Crear objeto sf (opcional, si vas a usarlo como spatial)
test_chapinero_sf <- st_as_sf(test_chapinero,
coords = c("lon", "lat"),
crs = 4326)
# Visualizar en el mapa
leaflet() %>%
addTiles() %>%
addCircles(lng = test_chapinero$lon,
lat = test_chapinero$lat)
# Asegúrate de que test_chapinero_sf esté definido
test_chapinero_sf <- st_as_sf(test_chapinero,
coords = c("lon", "lat"),
crs = 4326)
# Transformar a sistema proyectado colombiano (MAGNA-SIRGAS)
test_chapinero_metros <- st_transform(test_chapinero_sf, crs = 3116)
# Transformar también los malls si no lo has hecho aún (puedes omitir si ya existe)
mall_sf_bogota_metros <- st_transform(mall_sf_bogota, crs = 3116)
# Calcular matriz de distancias
dist_matrix_mall_test <- st_distance(test_chapinero_metros, mall_sf_bogota_metros)
# Calcular la distancia mínima a un mall para cada apartamento en test
dist_min_mall_test <- apply(dist_matrix_mall_test, 1, min)
# Agregar la distancia mínima a la base de datos test_chapinero
test_chapinero_metros$distancia_mall <- as.numeric(dist_min_mall_test)
# Agregar también la distancia como columna simple (opcional, para df sin geometría)
test_chapinero <- test_chapinero %>%
mutate(distancia_mall = dist_min_mall_test)
# Revisar resultados
head(test_chapinero)
# Transformar test_chapinero a objeto sf si aún no está
test_chapinero_sf <- st_as_sf(test_chapinero,
coords = c("lon", "lat"),
crs = 4326)
# Transformar a sistema de coordenadas proyectado (MAGNA-SIRGAS)
test_chapinero_metros <- st_transform(test_chapinero_sf, crs = 3116)
# Transformar los CAIs a CRS 3116 si no lo hiciste antes
cai_sf_bogota_metros <- st_transform(cai_sf_bogota, crs = 3116)
# Calcular la matriz de distancias
dist_matrix_cai_test <- st_distance(test_chapinero_metros, cai_sf_bogota_metros)
# Calcular la distancia mínima al CAI más cercano para cada apartamento
dist_min_cai_test <- apply(dist_matrix_cai_test, 1, min)
# Agregar la distancia mínima como nueva columna
test_chapinero_metros$distancia_cai <- as.numeric(dist_min_cai_test)
# Agregar la distancia también al data frame base (sin geometría)
test_chapinero <- test_chapinero %>%
mutate(distancia_cai = dist_min_cai_test)
# Verificar
head(test_chapinero)
# Asegúrate de tener test_chapinero_sf como objeto sf
test_chapinero_sf <- st_as_sf(test_chapinero,
coords = c("lon", "lat"),
crs = 4326)
# Transformar a sistema de coordenadas proyectado (MAGNA-SIRGAS / Bogotá)
test_chapinero_metros <- st_transform(test_chapinero_sf, crs = 3116)
# Asegúrate de tener las paradas de bus transformadas a CRS 3116
bus_stop_metros <- st_transform(bus_stop_sf, crs = 3116)
# Calcular la matriz de distancias entre apartamentos y paradas de bus
dist_matrix_bus_test <- st_distance(test_chapinero_metros, bus_stop_metros)
# Calcular la distancia mínima a una parada de bus
dist_min_bus_test <- apply(dist_matrix_bus_test, 1, min)
# Agregar la distancia mínima a test_chapinero_metros
test_chapinero_metros$distancia_bus <- as.numeric(dist_min_bus_test)
# Agregar la distancia a la versión sin geometría
test_chapinero <- test_chapinero %>%
mutate(distancia_bus = dist_min_bus_test)
# Verificar
head(test_chapinero)
# Asegúrate de que test_chapinero_sf tenga geometría (EPSG:4326)
test_chapinero_sf <- st_as_sf(test_chapinero,
coords = c("lon", "lat"),
crs = 4326)
# 1. Transformar los datos al sistema de coordenadas proyectado (MAGNA-SIRGAS)
test_chapinero_metros <- st_transform(test_chapinero_sf, crs = 3116)
# 2. Asegúrate de tener avenidas_metros definido previamente
# (Ya creado en tu código anterior como st_transform(avenidas_sf, crs = 3116))
# 3. Calcular la matriz de distancias entre apartamentos y avenidas principales
dist_matrix_avenidas_test <- st_distance(test_chapinero_metros, avenidas_metros)
# 4. Calcular la distancia mínima a una avenida
dist_min_avenida_test <- apply(dist_matrix_avenidas_test, 1, min)
# 5. Agregar la distancia mínima a test_chapinero_metros
test_chapinero_metros$distancia_avenida <- as.numeric(dist_min_avenida_test)
# 6. Agregar también a la base de datos test_chapinero sin geometría
test_chapinero <- test_chapinero %>%
mutate(distancia_avenida = dist_min_avenida_test)
# 7. Verificar resultados
head(test_chapinero)
library(tidytext)
library(dplyr)
# Tokenización de la columna 'description'
test_chapinero_tokens <- test_chapinero %>%
unnest_tokens(word, description)
# Quitar stop words
data("stop_words")
test_chapinero_tokens_clean <- test_chapinero_tokens %>%
anti_join(stop_words)
test_chapinero_tokens_clean %>%
count(word, sort = TRUE)
library(dplyr)
#Vector palabras agrupadas
parking <- c("parqueadero", "garaje", "parqueaderos", "garajes")
terrace <- c("terraza", "balcon")
gym <- "gimnasio"
laundry <- "lavanderia"
elevator <- "ascensor"
#Variable dummy para cada caracteristica
dummies_df_test <- test_chapinero_tokens_clean %>%
mutate(binaria_parking = word %in% parking,
binaria_terrace = word %in% terrace,
binaria_gym = word %in% gym,
binaria_laundry = word %in% laundry,
binaria_elevator = word %in% elevator) %>%
group_by(property_id) %>%
summarise(across(starts_with("binaria_"), ~as.integer(any(.))))
# Unir a df
test_chapinero <- left_join(test_chapinero, dummies_df_test, by = "property_id")
View(test_chapinero)
# Variables categóricas a convertir en factor
cols_factor <- c(
'year',
'property_type',
'binaria_parking',
'binaria_terrace',
'binaria_gym',
'binaria_laundry',
'binaria_elevator'
)
# Filtrar y preparar datos
train_factors <- train_localidades %>%
select(
property_id,
price,
year,
property_type,
distancia_cai,
distancia_mall,
distancia_bus,
distancia_avenida,
binaria_parking,
binaria_terrace,
binaria_gym,
binaria_laundry,
binaria_elevator
) %>%
mutate(across(all_of(cols_factor), as.factor)) %>%
as.data.frame()
# Quitar NAs del dataframe preparado
train_factors <- na.omit(train_factors)
# Variables predictoras
variables_predictoras <- c(
'year',
'property_type',
'distancia_cai',
'distancia_mall',
'distancia_bus',
'distancia_avenida',
'precio_mt2',
'binaria_parking',
'binaria_terrace',
'binaria_gym',
'binaria_laundry',
'binaria_elevator'
)
# Definir fórmula del modelo
variables <- paste(variables_predictoras, collapse = " + ")
formula_modelo <- as.formula(paste("price ~", variables))
# Las columnas estén en el mismo formato que en entrenamiento
cols_factor <- c(
'year',
'property_type',
'binaria_parking',
'binaria_terrace',
'binaria_gym',
'binaria_laundry',
'binaria_elevator'
)
# Preprocesamiento test
test <- test_chapinero %>%
select(
property_id,
year,
property_type,
distancia_cai,
distancia_mall,
distancia_bus,
distancia_avenida,
binaria_parking,
binaria_terrace,
binaria_gym,
binaria_laundry,
binaria_elevator
) %>%
mutate(across(all_of(cols_factor), as.factor)) %>%
as.data.frame()
