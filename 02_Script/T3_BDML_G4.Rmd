---
title: "Taller 3"
author: LAURA SARIF RIVERA SANABRIA,   NICOLAS JACOME VELASCO, JORGE ELIECER VIAFARA
  MORALES, ZAIRA ALEJANDRA GARCIA BERNAL
date: "2025-05-03"
output: html_document
---

# 1. Definición de entorno de trabajo

```{r}
# Instalar y cargar el paquetes
if (!require("pacman")) install.packages("pacman")
library(pacman)

if (!require("MLmetrics")) install.packages("MLmetrics")
library(MLmetrics)

# Usar pacman para cargar (e instalar si es necesario) los paquetes
p_load(tidyverse,   # Manipulación y visualización de datos 
       dplyr,       # Manipulación de datos
       ggplot2,     # Visualización de datos en gráficas
       readr,       # Importación de datos
       stargazer,   # Formato para tablas
       utils,       # Lctura de archivos y manipulación de datos
       skimr,       # Resumen estadístico 
       caret,       # Creación y validación de modelos predictivos 
       glmnet,      # Modelos de regresión penalizados (Ridge, Lasso)
       xgboost,     # Implementación de Gradient Boosting
       rpart,       # Árboles de decisión
       rpart.plot,  # Visualización de árboles generados por rpart
       pROC,        # Curvas ROC y métricas 
       Metrics,     # Métricas de evaluación
       httr,        # Solicitudes http
       rio,         # Facilidad para importar data
       plotly,      # Gráficos interactivos
       osmdata,     # Obtener información de open street maps
       sf,          # Leer/escribir/manipular datos espaciales
       leaflet,     # Mapas interactivos
       gridExtra,   # Graficar en grid
       tmaptools,   # Geocode_OMS()
       geosphere   # Calcular distancias geográficas como Haversine
       )
```

## 1.1 Carga base de datos

```{r}
# 1. Carga de datos train 
## Definir URL del archivo Excel en GitHub
url_excel_train <- "https://raw.githubusercontent.com/GeorgeWton1986/T3_BDML/refs/heads/main/03_Stores/train.csv"

## Descargar el archivo temporalmente
temp_file <- tempfile(fileext = ".csv")
GET(url_excel_train, write_disk(temp_file, overwrite = TRUE))

## Leer el archivo CSV en un dataframe
train_aptos <- read_csv(temp_file)


# 2. Carga de datos test hogares
## Definir URL del archivo Excel en GitHub
url_excel_test <- "https://raw.githubusercontent.com/GeorgeWton1986/T3_BDML/refs/heads/main/03_Stores/test.csv"

## Descargar el archivo temporalmente
temp_file <- tempfile(fileext = ".csv")
GET(url_excel_test, write_disk(temp_file, overwrite = TRUE))

# Leer el archivo CSV en un dataframe
test_aptos <- read_csv(temp_file)
```

## 1.2 Inspección y tratamiento BD train

```{r}
# Nombre de las columnas de la base train_hogares
colnames(train_aptos)

# Seleccion de la columnas id de hogares
train_aptos %>%
  select(property_id) %>%
  head()

# Resumen de apartamentos de la base train_hogares
skim(train_aptos)

# Tratamiento de missing values
train_miss <- skim(train_aptos) %>%
  filter(skim_type == "numeric") %>%
  select(skim_variable, n_missing)  

nobs_train <- nrow(train_aptos)

# Porcentaje de missing
train_aptos_miss<- train_miss %>% 
  mutate(p_missing= n_missing/nobs_train) %>% 
  filter(n_missing!= 0) %>% 
  arrange(-n_missing)

train_aptos_miss

# Visualizar variables con missing values

## Gráfico para surface_total (área total)
graf_ms1 <- ggplot(train_aptos, aes(surface_total)) +
  geom_histogram(color = "#000000", fill = "#0099F8") +
  geom_vline(xintercept = median(train_aptos$surface_total, na.rm = TRUE), linetype = "dashed", color = "red") +
  geom_vline(xintercept = mean(train_aptos$surface_total, na.rm = TRUE), linetype = "dashed", color = "blue") + 
  ggtitle("GRÁFICA 1 - Área total") +
  theme_bw() +
  theme(plot.title = element_text(size = 18))

ggsave("../04_Views/GRAFICO1-HISTOGRAMA-AREATOTAL.png", plot = graf_ms1, dpi = 150, width = 8, height = 6)

## Gráfico para surface_covered (área privada)
graf_ms2 <- ggplot(train_aptos, aes(surface_covered)) +
  geom_histogram(color = "#000000", fill = "#0099F8") +
  geom_vline(xintercept = median(train_aptos$surface_covered, na.rm = TRUE), linetype = "dashed", color = "red") +
  geom_vline(xintercept = mean(train_aptos$surface_covered, na.rm = TRUE), linetype = "dashed", color = "blue") + 
  ggtitle("GRÁFICA 2 - Área privada") +
  theme_bw() +
  theme(plot.title = element_text(size = 18))

ggsave("../04_Views/GRAFICO2-HISTOGRAMA-AREAPRIVADA.png", plot = graf_ms2, dpi = 150, width = 8, height = 6)

## Gráfico para rooms (habitaciones)
graf_ms3 <- ggplot(train_aptos, aes(rooms)) +
  geom_histogram(color = "#000000", fill = "#0099F8") +
  geom_vline(xintercept = median(train_aptos$rooms, na.rm = TRUE), linetype = "dashed", color = "red") +
  geom_vline(xintercept = mean(train_aptos$rooms, na.rm = TRUE), linetype = "dashed", color = "blue") + 
  ggtitle("GRÁFICA 3 -Habitaciones") +
  theme_bw() +
  theme(plot.title = element_text(size = 18))

ggsave("../04_Views/GRAFICO3-HISTOGRAMA-HABITACIONES.png", plot = graf_ms3, dpi = 150, width = 8, height = 6)

## Gráfico para bathrooms (baños)
graf_ms4 <- ggplot(train_aptos, aes(bathrooms)) +
  geom_histogram(color = "#000000", fill = "#0099F8") +
  geom_vline(xintercept = median(train_aptos$bathrooms, na.rm = TRUE), linetype = "dashed", color = "red") +
  geom_vline(xintercept = mean(train_aptos$bathrooms, na.rm = TRUE), linetype = "dashed", color = "blue") + 
  ggtitle("GRÁFICA 4 - Baños") +
  theme_bw() +
  theme(plot.title = element_text(size = 18))

ggsave("../04_Views/GRAFICO4-HISTOGRAMA-BAÑOS.png", plot = graf_ms4, dpi = 150, width = 8, height = 6)

# Imputación de variables con la mediana y moda

## 1. Variable surface_total con mediana
mediana_surface_total <- median(train_aptos$surface_total, na.rm = TRUE)

train_aptos <- train_aptos  %>%
  mutate(surface_total = ifelse(is.na(surface_total) == TRUE, mediana_surface_total, surface_total))

## 2. Variable surface_covered con mediana
mediana_surface_covered <- median(train_aptos$surface_covered, na.rm = TRUE)

train_aptos <- train_aptos  %>%
  mutate(surface_covered = ifelse(is.na(surface_covered) == TRUE, mediana_surface_covered, surface_covered))

## 3.  Variable rooms con la moda
moda_rooms <- train_aptos %>% 
  filter(!is.na(rooms)) %>% 
  count(rooms) %>% 
  arrange(desc(n)) %>% 
  slice(1) %>% 
  pull(rooms)

train_aptos <- train_aptos  %>%
  mutate(rooms = ifelse(is.na(rooms) == TRUE, moda_rooms, rooms))

## 4.Variable bathrooms con la moda
moda_bathrooms <- train_aptos %>% 
  filter(!is.na(bathrooms)) %>% 
  count(bathrooms) %>% 
  arrange(desc(n)) %>% 
  slice(1) %>% 
  pull(bathrooms)

train_aptos <- train_aptos  %>%
  mutate(bathrooms = ifelse(is.na(bathrooms) == TRUE, moda_bathrooms, bathrooms))

# Validación de correcta imputación de missing values en variables numéricas
skim(train_aptos)
```

Explorar la base para identificar outliers o anomalias de los datos

```{r}
train_aptos <- as.data.frame(train_aptos)
stargazer(train_aptos, type = "text")

# Calcular el precio por metro cuadrado
train_aptos <- train_aptos %>%
  mutate(precio_mt2 = round(price / surface_total, 0))

skim(train_aptos)

# Histograma del precio por metro cuadrado
graf_5 <- ggplot(train_aptos, aes(precio_mt2)) +
  geom_histogram(color = "#000000", fill = "#0099F8") +
  ggtitle("GRÁFICA 4 - Precio por metro cuadrado (millones)") +
  scale_x_continuous(labels = function(x) x / 1e6) +
  theme_bw() +
  theme(plot.title = element_text(size = 18))

ggsave("../04_Views/GRAFICO5-HISTOGRAMA-PRECIOXMETROCUADRADO.png", plot = graf_5, dpi = 150, width = 8, height = 6)

# Box plot del precio por metro cuadrado
graf_6 <- train_aptos %>%
  ggplot(aes(y = precio_mt2)) +
  geom_boxplot(fill = "darkblue", alpha = 0.4) +
  labs(
    title = "Muestra completa",
    y = "Precio por metro cuadrado (millones)", x = "") +
  scale_y_continuous(labels = function(x) x / 1e6) +
  theme_bw()

ggsave("../04_Views/GRAFICO6-BOXPLOT-PRECIOXMETROCUADRADO.png", plot = graf_6, dpi = 150, width = 8, height = 6)

# Ante outliers superiores se aplica la Metodología de percentil 99%
#p1 <- quantile(train_aptos$precio_mt2, probs = 0.01, na.rm = TRUE)
p99 <- quantile(train_aptos$precio_mt2, probs = 0.99, na.rm = TRUE)

train_aptos <- train_aptos %>%
  filter(precio_mt2 <= p99)

# Filtrar solo los valores menores o iguales al límite superior
graf_7 <- train_aptos %>%
  ggplot(aes(y = precio_mt2)) +
  geom_boxplot(fill = "darkblue", alpha = 0.4) +
  labs(
    title = "Muestra filtrada - P99",
    y = "Precio por metro cuadrado (millones)", x = "") +
  scale_y_continuous(labels = function(x) x / 1e6) +
  theme_bw()

ggsave("../04_Views/GRAFICO6-BOXPLOT-PRECIOXMETROCUADRADO-P99.png", plot = graf_7, dpi = 150, width = 8, height = 6)

```

Identificar en el mapa la ubicacion de los apartamentos y casas

```{r}
# Observamos la primera visualización de la ubicación de los inmubles de la base train_aptos
leaflet() %>%
  addTiles() %>%
  addCircles(lng = train_aptos$lon, 
             lat = train_aptos$lat)
```

Identificar Chapinero en Bogotá

```{r}
# Ahora solo nos quedaremos con las observaciones que efectivamente están dentro de Chapinero y no están mal georeferenciadas
limites <- getbb("Chapinero, Bogotá, Colombia")
limites

train_chapinero <- train_aptos %>%
  filter(
    between(lon, limites[1, "min"], limites[1, "max"]) & 
    between(lat, limites[2, "min"], limites[2, "max"])
  )

leaflet() %>%
  addTiles() %>%
  addCircles(lng = train_chapinero$lon, 
             lat = train_chapinero$lat)
```


Variables en descripción

Tokenizar

```{r}
library(tidytext)
library(dplyr)

# Tokenización de la columna 'description'
train_chapinero_tokens <- train_chapinero %>%
  unnest_tokens(word, description)  # Esto tokeniza por palabra

# Ahora puedes limpiar (eliminar stopwords, por ejemplo)
data("stop_words")
train_chapinero_tokens_clean <- train_chapinero_tokens %>%
  anti_join(stop_words)

```
Palabras más comunes

```{r}
train_chapinero_tokens_clean %>%
  count(word, sort = TRUE)
```

```{r}
train_chapinero_tokens_clean %>%
  count(property_id, word) %>%
  spread(key = word, value = n, fill = 0)
```

```{r}
library(dplyr)

# Vector con palabras agrupadas
parking <- c("parqueadero", "garaje")
terrace <- "terraza"
gym <- "gimnasio"
laundry <- "lavanderia"
elevator <- "ascensor"

# Variable dummy para cada caracteristica
dummies_df <- train_chapinero_tokens_clean %>%
  mutate(binaria_parking = word %in% parking,
         binaria_terrace = word %in% terrace,
         binaria_gym = word %in% gym,
         binaria_laundry = word %in% laundry,
         binaria_elevator = word %in% elevator) %>%
  group_by(property_id) %>%
  summarise(across(starts_with("has_"), ~as.integer(any(.))))  # 1 si aparece, 0 si no

# Unir a df 
train_chapinero_final <- left_join(train_chapinero, dummies_df, by = "property_id")

```


Identificar distancia a parques

```{r}
# Definir el límite de Chapinero en Bogotá
limites_chapinero <- getbb("Chapinero, Bogotá, Colombia")

# Extraer la información de los parques en Chapinero
parques_chapinero <- opq(bbox = limites_chapinero) %>%
  add_osm_feature(key = "leisure", value = "park")

# Convertir los datos a formato sf
parques_sf_chapinero <- osmdata_sf(parques_chapinero)

# Filtrar los parques dentro del límite de Chapinero
parques_chapinero_geometria <- parques_sf_chapinero$osm_polygons %>%
  dplyr::select(osm_id, name)

# Verificar los parques en Chapinero
leaflet() %>%
  addTiles() %>%
  addPolygons(data = parques_chapinero_geometria, color = "red", weight = 2, opacity = 0.8, popup = parques_chapinero_geometria$name)

```



```{r}
# Calcular los centroides de los parques en Chapinero
centroides_chapinero <- st_centroid(parques_chapinero_geometria, byid = TRUE)

# Extraer las coordenadas de los centroides
centroides_chapinero <- centroides_chapinero %>%
  mutate(x = st_coordinates(centroides_chapinero)[, "X"]) %>%
  mutate(y = st_coordinates(centroides_chapinero)[, "Y"])

# Convertir los centroides a un objeto sf
centroides_chapinero_sf <- st_as_sf(centroides_chapinero, coords = c("x", "y"), crs = 4326)

# Visualizar los centroides
leaflet() %>%
  addTiles() %>%
  addCircles(data = centroides_chapinero_sf, color = "darkblue", radius = 50, opacity = 0.7)

```

```{r}
# Convertir los apartamentos a un objeto sf 
sf_aptos <- st_as_sf(train_chapinero, coords = c("lon", "lat"), crs = 4326)

# Calcular la distancia entre los apartamentos y los centroides de los parques
dist_matrix <- st_distance(sf_aptos, centroides_chapinero_sf)

# Obtener la distancia mínima para cada apartamento
dist_min <- apply(dist_matrix, 1, min)

# Añadir la distancia mínima a la base de datos de los apartamentos
train_chapinero <- train_chapinero %>% mutate(distancia_parque = dist_min)

# Crear el histograma de la distancia mínima a los parques
p <- ggplot(train_chapinero, aes(x = distancia_parque)) +
  geom_histogram(bins = 50, fill = "darkblue", alpha = 0.4) +
  labs(x = "Distancia mínima a un parque en metros", y = "Cantidad",
       title = "Distribución de la distancia a los parques en Chapinero") +
  theme_bw()

ggsave("../04_Views/GRAFICO8-DISTANCIAPARQUES.png", plot = p, dpi = 150, width = 8, height = 6)

```

Identificar distancia a bus
```{r}
# Definir el área de Chapinero
limites_chapinero <- getbb("Chapinero, Bogotá, Colombia")

# Descargar estaciones de TransMilenio (usualmente etiquetadas como 'bus_station' o 'platform')
transmi_query <- opq(bbox = limites_chapinero) %>%
  add_osm_feature(key = "public_transport", value = "platform") %>%
  add_osm_feature(key = "bus", value = "yes", value_exact = FALSE)

# Obtener datos como sf
transmi_data <- osmdata_sf(transmi_query)

# Usar puntos de plataformas si están disponibles
transmi_sf <- transmi_data$osm_points %>%
  dplyr::select(osm_id, name)

# Verificar
leaflet() %>%
  addTiles() %>%
  addCircles(data = transmi_sf, color = "red", radius = 50, label = ~name)

```

```{r}
# Convertir estaciones a sf si no lo son
transmi_sf <- st_as_sf(transmi_sf)

# Asegurar que ambos están en la misma proyección
train_chapinero_sf <- st_as_sf(train_chapinero, coords = c("lon", "lat"), crs = 4326)
train_chapinero_sf <- st_transform(train_chapinero_sf, 4326)
transmi_sf <- st_transform(transmi_sf, 4326)

# Calcular matriz de distancias
dist_matrix_transmi <- st_distance(train_chapinero_sf, transmi_sf)

# Obtener la distancia mínima a estación TransMilenio
dist_min_transmi <- apply(dist_matrix_transmi, 1, min)

# Agregarla a la base original
train_chapinero <- train_chapinero %>%
  mutate(distancia_transmi = dist_min_transmi)
```

Identificar distancia a CAI
```{r}
# Obtener bbox de Chapinero
limites_chapinero <- getbb("Chapinero, Bogotá, Colombia")

# Obtener CAI (policías)
cai_query <- opq(bbox = limites_chapinero) %>%
  add_osm_feature(key = "amenity", value = "police")

cai_data <- osmdata_sf(cai_query)
cai_sf <- cai_data$osm_points %>% dplyr::select(osm_id, name)
cai_sf <- st_transform(cai_sf, 4326)

# Convertir apartamentos a sf si no lo están
aptos_sf <- st_as_sf(train_chapinero, coords = c("lon", "lat"), crs = 4326)

# Calcular distancias
dist_matrix_cai <- st_distance(aptos_sf, cai_sf)
dist_min_cai <- apply(dist_matrix_cai, 1, min)

# Agregar a la base
train_chapinero <- train_chapinero %>%
  mutate(distancia_cai = dist_min_cai)

```

Identificar distancia avenidas principales
```{r}
# Obtener vías principales en Chapinero
vias_query <- opq(bbox = limites_chapinero) %>%
  add_osm_feature(key = "highway", value = c("primary", "trunk"))

vias_data <- osmdata_sf(vias_query)
vias_sf <- vias_data$osm_lines %>% dplyr::select(osm_id, name)
vias_sf <- st_transform(vias_sf, 4326)

# Calcular distancia a la vía principal más cercana
dist_matrix_vias <- st_distance(aptos_sf, vias_sf)
dist_min_vias <- apply(dist_matrix_vias, 1, min)

# Agregar a la base
train_chapinero <- train_chapinero %>%
  mutate(distancia_via_principal = dist_min_vias)

```


## 1.2 Inspección y tratamiento de BD test

```{r}
# Nombre de las columnas de la base train_hogares
colnames(test_aptos)

# Seleccion de la columnas id de hogares
test_aptos %>%
  select(property_id) %>%
  head()

# Resumen de apartamentos de la base train_hogares
skim(test_aptos)

# Imputación de missing values con la media de train_aptos

## 1. Variable surface_total con mediana de train
test_aptos <- test_aptos  %>%
  mutate(surface_total = ifelse(is.na(surface_total) == TRUE, mediana_surface_total, surface_total))

## 2. Variable surface_covered con mediana de train
test_aptos <- test_aptos  %>%
  mutate(surface_covered = ifelse(is.na(surface_covered) == TRUE, mediana_surface_covered, surface_covered))

## 3.  Variable rooms con la moda de train
test_aptos <- test_aptos  %>%
  mutate(rooms = ifelse(is.na(rooms) == TRUE, moda_rooms, rooms))

## 4.Variable bathrooms con moda de train
test_aptos <- test_aptos  %>%
  mutate(bathrooms = ifelse(is.na(bathrooms) == TRUE, moda_bathrooms, bathrooms))

# Validación de correcta imputación de missing values en test
skim(test_aptos)
```

## 1.3 Estadísticas descriptivas

```{r}
# Estadísticas luego del tratamiento de las bases
#estadisticas_train <- skim(train_aptos)
#estadisticas_test <- skim(test_aptos)

# Guardar tablas
#write.table(estadisticas_train, "../04_Views/TABLA1-ESTADISTICAS-TRAIN.txt", sep = "\t", row.names = FALSE, quote = FALSE)
#write.table(estadisticas_test, "../04_Views/TABLA2-ESTADISTICAS-TEST.txt", sep = "\t", row.names = FALSE, quote = FALSE)

# Selecciona variables clave para modelos


```




# 2. Entrenamiento de modelos

## 2.1 Elastic net

### 2.1.1 Entrenamiento

```{r}

```

### 2.1.2 Predicción

```{r}

```

### 2.1.3 Template Kaggle

```{r}
# Descargar archivo
write.csv(pred_EN1,
          "C:/../03_Stores/10-04_G4_EN1.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_EN2,
          "C:/../03_Stores/10-04_G4_EN2.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_EN3,
          "C:/../03_Stores/10-04_G4_EN3.csv", row.names = FALSE, 
          quote = FALSE)
```

## 2.2 CARTs

### 2.2.1 Entrenamiento

```{r}

```

### 2.2.2 Predicción

```{r}

```

### 2.2.3 Template Kaggle

```{r}
# Descargar archivo
write.csv(pred_CARTS1,
          "C:/../03_Stores/10-04_G4_CARTS1.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_CARTS2,
          "C:/../03_Stores/10-04_G4_CARTS2.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_CARTS3,
          "C:/../03_Stores/10-04_G4_CARTS3.csv", row.names = FALSE, 
          quote = FALSE)
```

## 2.3 Random Forest

### 2.3.1 Entrenamiento

```{r}

```

### 2.3.2 Predicción

```{r}

```

### 2.3.3 Template Kaggle

```{r}
# Descargar archivo
write.csv(pred_RF1,
          "C:/../03_Stores/10-04_G4_RANDOM-FOREST1.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_RF2,
          "C:/../03_Stores/10-04_G4_RANDOM-FOREST2.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_RF3,
          "C:/../03_Stores/10-04_G4_RANDOM-FOREST3.csv", row.names = FALSE, 
          quote = FALSE)
```

## 2.4 Boosting

### 2.4.1 Entrenamiento

```{r}

```

### 2.4.2 Predicción

```{r}

```

### 2.4.3 Template Kaggle

```{r}
# Descargar archivo
write.csv(pred_boosting1,
          "C:/../03_Stores/10-04_G4_BOOSTING1.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_boosting2,
          "C:/../03_Stores/10-04_G4_BOOSTING2.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_boosting3,
          "C:/../03_Stores/10-04_G4_BOOSTING3.csv", row.names = FALSE, 
          quote = FALSE)
```

## 2.5 Redes neuronales

### 2.5.1 Entrenamiento

```{r}

```

### 2.5.2 Predicción

```{r}

```

### 2.5.3 Template Kaggle

```{r}
# Descargar archivo
write.csv(pred_rneuronales1,
          "C:/../03_Stores/10-04_G4_REDES-NEURONALES1.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_rneuronales2,
          "C:/../03_Stores/10-04_G4_REDES-NEURONALES2.csv", row.names = FALSE, 
          quote = FALSE)

write.csv(pred_rneuronales3,
          "C:/../03_Stores/10-04_G4_REDES-NEURONALES3.csv", row.names = FALSE, 
          quote = FALSE)
```

## 2.6 Super Learners

```{r}

```

## 2.7 Regresión lineal

```{r}

```
